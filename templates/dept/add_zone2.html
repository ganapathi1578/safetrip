{% load static %}
{# templates/dept/add_zone.html - a fragment to be injected into #zoneModalContent #}

<div class="add-zone-fragment">
  <div class="modal-header">
    <h2>Add Zone</h2>
    <button class="close-modal" aria-label="Close">&times;</button>
  </div>

  <div class="modal-body">
    <form method="post" id="zone-form" novalidate>
      {% csrf_token %}
      {# Note: your view uses prefix="zone", so the form has inputs like name="zone-latitude" etc. #}

      <div class="zone-left">
        <h3>Zone Details</h3>
        <div class="form-row">
          {{ zone_form.name.label_tag }}<br/>
          {{ zone_form.name }}
        </div>

        <div class="form-row">
          {{ zone_form.latitude.label_tag }}<br/>
          {{ zone_form.latitude }}
        </div>

        <div class="form-row">
          {{ zone_form.longitude.label_tag }}<br/>
          {{ zone_form.longitude }}
        </div>

        <div class="form-row">
          {{ zone_form.radius.label_tag }}<br/>
          {{ zone_form.radius }}
        </div>

        <hr/>

        <h4>Zone Types</h4>
        <div id="types-area">
          {{ types_formset.management_form }}
          {% for form in types_formset.forms %}
            <div class="type-block">
              {{ form.as_p }}
            </div>
          {% endfor %}
        </div>

        <hr/>

        <h4>Alerts</h4>
        <div id="alerts-area">
          {{ alerts_formset.management_form }}
          {% for form in alerts_formset.forms %}
            <div class="alert-block">
              {{ form.as_p }}
            </div>
          {% endfor %}
        </div>

        <div class="form-actions" style="margin-top:12px;">
          <button type="submit" class="btn btn-primary">Save Zone</button>
          <button type="button" class="btn btn-outline close-modal" id="cancelZoneBtn">Cancel</button>
        </div>
      </div>

      <div class="zone-right">
        <h3>Pick on Map</h3>
        <p class="small">Click the map to place a point; draw a circle/polygon to set area. Fields below are auto-filled.</p>

        <div id="modal-map" style="height: 360px; border:1px solid #ddd; border-radius:6px;"></div>

        <div style="margin-top:8px;">
          <small>Coordinates preview:</small>
          <div id="coordsPreview">—</div>
        </div>

        <div style="margin-top:8px;">
          <button type="button" class="btn btn-outline" id="clearDrawBtn">Clear</button>
          <button type="button" class="btn btn-outline" id="useMyLocationBtn">Use My Location</button>
        </div>
      </div>

    </form>
  </div>
</div>

{# Optional inline styles for fragment layout — you may move to CSS file #}
<style>
.add-zone-fragment .modal-body { display: flex; gap: 16px; align-items: flex-start; }
.add-zone-fragment .zone-left { flex: 1 1 460px; }
.add-zone-fragment .zone-right { width: 420px; }
.small { font-size: 0.9rem; color: #666; }
.form-row { margin-bottom: 8px; }
.type-block, .alert-block { border: 1px solid #eee; padding: 8px; margin-bottom:6px; border-radius:4px; }
</style>

{# Map + wiring script (runs when this fragment is injected into DOM) #}
<script>
(function () {
  // Wait until element exists in DOM
  const root = document.currentScript ? document.currentScript.parentElement : document.querySelector('.add-zone-fragment');
  if (!root) return;

  // Helper: select by Django prefix names (view used prefix="zone")
  const latInput = root.querySelector('input[name="zone-latitude"]');
  const lngInput = root.querySelector('input[name="zone-longitude"]');
  const radiusInput = root.querySelector('input[name="zone-radius"]');

  const coordsPreview = root.querySelector('#coordsPreview');

  // Map setup
  // If global leaflet not found, bail
  if (typeof L === 'undefined') {
    coordsPreview.innerText = 'Leaflet not loaded.';
    return;
  }

  // create map inside modal-map
  const mapEl = root.querySelector('#modal-map');
  const modalMap = L.map(mapEl).setView([23.7272, 92.7173], 13); // default center (Aizawl)
  // tile layer (you can replace with your tile provider)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(modalMap);

  // Feature group to hold drawn items
  const drawnFG = new L.FeatureGroup().addTo(modalMap);
  let currentLayer = null;

  // Add draw control (circle + polygon + marker)
  const drawControl = new L.Control.Draw({
    draw: {
      polyline: false,
      rectangle: false,
      marker: true,
      circle: {
        showRadius: true
      },
      polygon: {
        allowIntersection: false,
        showArea: true
      }
    },
    edit: {
      featureGroup: drawnFG,
      edit: true,
      remove: true
    }
  });
  modalMap.addControl(drawControl);

  // clicking map places a marker (and sets lat/lng)
  modalMap.on('click', function(e) {
    // if a drawn layer exists, remove it (we keep only one)
    if (currentLayer) { drawnFG.removeLayer(currentLayer); currentLayer = null; }
    const m = L.marker(e.latlng);
    currentLayer = m;
    drawnFG.addLayer(m);
    updateFormFromLayer(currentLayer, 'marker');
  });

  // when a draw is created (circle/polygon/marker)
  modalMap.on(L.Draw.Event.CREATED, function (e) {
    if (currentLayer) { drawnFG.removeLayer(currentLayer); currentLayer = null; }
    const layer = e.layer;
    currentLayer = layer;
    drawnFG.addLayer(layer);
    updateFormFromLayer(layer, e.layerType);
  });

  // when edited -> update
  modalMap.on('draw:edited', function (e) {
    e.layers.eachLayer(function (layer) {
      currentLayer = layer;
      updateFormFromLayer(layer, layer instanceof L.Circle ? 'circle' : (layer instanceof L.Marker ? 'marker' : 'polygon'));
    });
  });

  // when deleted -> clear fields
  modalMap.on('draw:deleted', function (e) {
    drawnFG.clearLayers();
    currentLayer = null;
    setFormValues('', '', '');
  });

  // Clear button
  const clearBtn = root.querySelector('#clearDrawBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', function () {
      drawnFG.clearLayers();
      currentLayer = null;
      modalMap.invalidateSize();
      setFormValues('', '', '');
    });
  }

  // Use browser geolocation (optional)
  const useLocBtn = root.querySelector('#useMyLocationBtn');
  if (useLocBtn) {
    useLocBtn.addEventListener('click', function () {
      if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
      navigator.geolocation.getCurrentPosition(function (pos) {
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        if (currentLayer) drawnFG.removeLayer(currentLayer);
        const mk = L.marker([lat, lng]).addTo(drawnFG);
        currentLayer = mk;
        modalMap.setView([lat, lng], 15);
        updateFormFromLayer(mk, 'marker');
      }, function (err) {
        alert('Unable to get location: ' + err.message);
      });
    });
  }

  // helper: compute centroid for polygon (simple average)
  function polygonCentroid(latlngs) {
    // latlngs expected as array of {lat, lng}
    let sx = 0, sy = 0, n = 0;
    latlngs.forEach(p => { sx += p.lat; sy += p.lng; n++; });
    return { lat: sx / n, lng: sy / n };
  }

  function updateFormFromLayer(layer, layerType) {
    if (!latInput || !lngInput || !radiusInput) {
      console.warn('zone inputs not found; ensure ZoneForm uses prefix "zone" and fields latitude/longitude/radius exist.');
    }

    if (layerType === 'circle' || layer instanceof L.Circle) {
      const c = layer.getLatLng();
      const r = Math.round(layer.getRadius()); // meters
      setFormValues(c.lat, c.lng, r);
      coordsPreview.innerText = `${c.lat.toFixed(6)}, ${c.lng.toFixed(6)} (r ${r} m)`;
    } else if (layerType === 'polygon' || layer instanceof L.Polygon) {
      // layer.getLatLngs() returns nested arrays (rings); take first ring
      let latlngs = layer.getLatLngs();
      if (Array.isArray(latlngs[0])) latlngs = latlngs[0];
      const c = polygonCentroid(latlngs);
      setFormValues(c.lat, c.lng, '');
      coordsPreview.innerText = `polygon centroid ${c.lat.toFixed(6)}, ${c.lng.toFixed(6)}`;
      // also optionally store polygon points into a hidden field if your model needs them:
      // set hidden input 'zone-polygon_points' if exists
      const points = latlngs.map(p => `${p.lat.toFixed(6)} ${p.lng.toFixed(6)}`).join(';');
      const polyField = root.querySelector('input[name="zone-polygon_points"], textarea[name="zone-polygon_points"]');
      if (polyField) polyField.value = points;
    } else { // marker
      const c = layer.getLatLng();
      setFormValues(c.lat, c.lng, '');
      coordsPreview.innerText = `${c.lat.toFixed(6)}, ${c.lng.toFixed(6)}`;
    }
  }

  function setFormValues(lat, lng, rad) {
    if (latInput) latInput.value = lat === '' ? '' : Number(lat).toFixed(6);
    if (lngInput) lngInput.value = lng === '' ? '' : Number(lng).toFixed(6);
    if (radiusInput) radiusInput.value = rad === '' ? '' : String(rad);
  }

  // If the form already contained initial lat/lng values (edit mode), show a marker
  (function prefillFromInputs() {
    try {
      const latVal = latInput ? (latInput.value || '') : '';
      const lngVal = lngInput ? (lngInput.value || '') : '';
      const radVal = radiusInput ? (radiusInput.value || '') : '';
      if (latVal && lngVal) {
        const lat = parseFloat(latVal), lng = parseFloat(lngVal);
        if (!isNaN(lat) && !isNaN(lng)) {
          let l;
          if (radVal && !isNaN(parseFloat(radVal))) {
            l = L.circle([lat, lng], { radius: parseFloat(radVal) });
          } else {
            l = L.marker([lat, lng]);
          }
          currentLayer = l;
          drawnFG.addLayer(l);
          modalMap.setView([lat, lng], 14);
          coordsPreview.innerText = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }
      }
    } catch (err) { console.warn(err); }
  })();

  // Wire close buttons inside fragment
  const closeBtns = root.querySelectorAll('.close-modal');
  closeBtns.forEach(b => b.addEventListener('click', function () {
    // hide parent modal container (closest .modal)
    const modal = root.closest('.modal');
    if (modal) { modal.style.display = 'none'; document.body.style.overflow = ''; }
  }));

  // Optional: intercept form submit to submit via AJAX (if you prefer)
  const form = root.querySelector('#zone-form');
  if (form) {
    form.addEventListener('submit', function (ev) {
      // comment out following 'return;' to enable AJAX submission
      // return; // default behavior: normal POST (works without AJAX)
      ev.preventDefault();
      // AJAX submit:
      const csrftoken = (document.cookie.split(';').map(c => c.trim()).find(c => c.startsWith('csrftoken=')) || '').split('=')[1];
      const data = new FormData(form);
      // ensure geometry fields present from currentLayer
      if (currentLayer) {
        if (currentLayer instanceof L.Circle) {
          const c = currentLayer.getLatLng();
          data.set('zone-latitude', c.lat.toFixed(6));
          data.set('zone-longitude', c.lng.toFixed(6));
          data.set('zone-radius', String(Math.round(currentLayer.getRadius())));
        } else if (currentLayer instanceof L.Polygon) {
          const latlngs = currentLayer.getLatLngs()[0] || currentLayer.getLatLngs();
          const centroid = polygonCentroid(latlngs);
          data.set('zone-latitude', centroid.lat.toFixed(6));
          data.set('zone-longitude', centroid.lng.toFixed(6));
          // set polygon points (if template defines zone-polygon_points)
          const pts = latlngs.map(p => `${p.lat.toFixed(6)} ${p.lng.toFixed(6)}`).join(';');
          if (form.querySelector('input[name="zone-polygon_points"], textarea[name="zone-polygon_points"]')) {
            data.set('zone-polygon_points', pts);
          }
        } else {
          const c = currentLayer.getLatLng();
          data.set('zone-latitude', c.lat.toFixed(6));
          data.set('zone-longitude', c.lng.toFixed(6));
        }
      }

      fetch("{% url 'add_zone' %}", {
        method: 'POST',
        credentials: 'same-origin',
        headers: { 'X-CSRFToken': csrftoken, 'X-Requested-With': 'XMLHttpRequest' },
        body: data
      }).then(r => {
        if (r.redirected) {
          window.location.href = r.url;
          return;
        }
        return r.text();
      }).then(html => {
        if (!html) return;
        // Replace modal content with returned HTML (form with errors or success message)
        const modal = root.closest('.modal');
        if (modal) {
          const contentEl = modal.querySelector('.modal-content') || modal;
          if (contentEl) contentEl.innerHTML = html;
        }
      }).catch(err => {
        alert('Error submitting: ' + err.message);
      });
    });
  }

})();

// static/javascript/zone_management.js
(function () {
  const addNewZoneBtn = document.getElementById('addNewZoneBtn');
  const zoneModal = document.getElementById('zoneModal');
  const zoneModalContent = document.getElementById('zoneModalContent') || document.getElementById('zoneModalContent');

  if (!addNewZoneBtn || !zoneModal || !zoneModalContent) {
    // Elements not present; maybe page doesn't include zone management UI
    return;
  }

  addNewZoneBtn.addEventListener('click', async function (e) {
    e.preventDefault();
    try {
      const resp = await fetch('/dept/add_zone/', {
        method: 'GET',
        credentials: 'same-origin',
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
      });
      if (!resp.ok) {
        zoneModalContent.innerHTML = '<div class="card"><p>Unable to load form.</p></div>';
        zoneModal.style.display = 'block';
        document.body.style.overflow = 'hidden';
        return;
      }
      const html = await resp.text();
      zoneModalContent.innerHTML = html;

      // If the injected fragment relies on inline <script> that uses document.currentScript,
      // the script won't run automatically if injected as text in some browsers.
      // To ensure execution, we re-evaluate scripts inside the fragment:
      (function executeInlineScripts(container) {
        const scripts = container.querySelectorAll('script');
        scripts.forEach(oldScript => {
          const newScript = document.createElement('script');
          if (oldScript.src) {
            newScript.src = oldScript.src;
            newScript.async = false;
          } else {
            newScript.textContent = oldScript.textContent;
          }
          oldScript.parentNode.replaceChild(newScript, oldScript);
        });
      })(zoneModalContent);

      // show modal
      zoneModal.style.display = 'block';
      document.body.style.overflow = 'hidden';

      // close handlers (in case fragment didn't add them)
      zoneModalContent.querySelectorAll('.close-modal').forEach(btn => {
        btn.addEventListener('click', () => {
          zoneModal.style.display = 'none';
          document.body.style.overflow = '';
        });
      });

      // optional: if you want to initialize anything else here, do it

    } catch (err) {
      console.error(err);
      zoneModalContent.innerHTML = `<div class="card"><p>Fetch error: ${err.message}</p></div>`;
      zoneModal.style.display = 'block';
      document.body.style.overflow = 'hidden';
    }
  });

  // allow clicking outside to close modal
  zoneModal.addEventListener('click', function (e) {
    if (e.target === zoneModal) {
      zoneModal.style.display = 'none';
      document.body.style.overflow = '';
    }
  });

})();

</script>
